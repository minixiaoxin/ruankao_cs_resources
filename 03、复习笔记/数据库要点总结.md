# 数据库要点总结

# 1、范式

关系数据库设计理论中的范式是规范化过程的一部分，用来确保数据结构符合良好的设计原则，避免冗余数据、数据不一致和可更新性异常等问题。以下是关系数据库中的各个范式介绍：

1. 第一范式（1NF）：所有属性都是原子性的，也就是每个列都只包含单一的、不可再分的数据。
2. 第二范式（2NF）：在满足第一范式的基础上，非主键列必须完全依赖于主键，而不能依赖于主键的一部分。
3. 第三范式（3NF）：在满足第二范式的基础上，任何非主键列都不能依赖于其他非主键列，即不存在传递依赖。
4. 巴斯-科德范式（BCNF）：在满足第二范式的基础上，消除主键列对其他非主键列存在的部分依赖和传递依赖关系。
5. 第四范式（4NF）：在满足BCNF的基础上，消除多值依赖，即一个关系中的某些属性可以由另外一个关系中的某些属性推导出来，这样就避免了存储重复数据的情况。
6. 第五范式（5NF）：在满足第四范式的基础上，消除关联依赖，即一个关系中某些属性可以通过其他不相关的关系推导出来。







数据库中的各范式是指关系数据库设计中的一些规范，用于规范化数据库的结构，保证数据的一致性和完整性。常见的范式有以下几种：

1. 第一范式（1NF）：每个属性都应该是原子性的，即不可再分。
2. 第二范式（2NF）：满足1NF的基础上，非主键属性必须完全依赖于主键，而不能只依赖于主键的一部分。
3. 第三范式（3NF）：满足2NF的基础上，非主键属性不能依赖于其他非主键属性，即不存在传递依赖。
4. 巴斯-科德范式（BCNF）：满足3NF的基础上，对于每一个非平凡函数依赖X → Y，X必须是Y的超键。
5. 第四范式（4NF）：满足BCNF的基础上，不能存在多值依赖或联合依赖。
6. 第五范式（5NF）：满足4NF的基础上，消除了所有可能的损失连接的依赖。

范式越高，数据库的结构越规范化，但是也会带来一些问题，如查询效率低下和存储空间浪费等。因此，在设计数据库时，需要根据实际情况和需求来选择合适的范式。

# 2、事务

数据库事务（Database Transaction）是指一组数据库操作，它们被视为一个单独的逻辑工作单元，并且要么全部执行成功，要么全部回滚（撤销）。



**四大特性ACID**:

1. 原子性（Atomicity）：事务是一个原子操作，要么全部执行成功，要么全部回滚。如果在执行期间发生了错误，所有的操作将会被撤销。
2. 一致性（Consistency）：事务执行前和执行后，数据库的状态必须保持一致。也就是说，事务执行的结果必须使数据库从一个一致性状态转换到另一个一致性状态。
3. 隔离性（Isolation）：并发访问数据库时，一个事务的执行不应该受到其他事务的影响。也就是说，当两个或多个事务同时执行时，每个事务都应该感觉不到其他事务的存在。
4. 持久性（Durability）：一旦事务提交，其所做的修改将永久保存在数据库中，即使系统崩溃也不会丢失。





## 3、事务异常

数据库事务可能出现的错误类型包括以下几种：

1. 数据库连接异常：当应用程序和数据库之间的连接断开时，事务中的操作将无法完成。
2. 并发访问冲突：当两个或多个事务尝试同时访问相同的数据时，可能会产生并发访问冲突。这可能导致某些事务失败或阻塞，直到其他事务完成。
3. 锁定超时：在某些情况下，如果一个事务需要锁定一条记录或一组记录，在等待其他事务释放锁时，可能会出现锁定超时的情况。
4. 数据库崩溃：如果数据库系统发生故障、崩溃或停止，事务可能会失败，因为此时数据库无法对其进行修改或回滚。
5. 网络中断：当网络连接断开或不稳定时，事务可能无法成功提交，因为提交需要从应用程序传输到数据库服务器。
6. 硬件故障：硬件故障可能会导致数据丢失或损坏，从而影响事务的完整性和可靠性。



## 01背包问题

1、

01背包问题是一个经典的动态规划问题，可以用以下步骤解答：

1. 定义状态：设f[i][j]表示前i个物品放入容量为j的背包中所获得的最大价值。
2. 状态转移方程：对于第i个物品，有两种情况，一种是放入背包中，一种是不放入背包中。如果放入背包中，则f[i][j] = f[i-1][j-w[i]] + v[i]，其中w[i]表示第i个物品的重量，v[i]表示第i个物品的价值；如果不放入背包中，则f[i][j] = f[i-1][j]。因此，状态转移方程为：f[i][j] = max(f[i-1][j], f[i-1][j-w[i]] + v[i])。
3. 初始化：f[0][j] = 0，f[i][0] = 0。
4. 最终结果：f[n][m]，其中n为物品的个数，m为背包的容量。
5. 时间复杂度：O(nm)，其中n为物品的个数，m为背包的容量。

下面是一个Python实现的例子：

```python
def knapsack(n, m, w, v):
    f = [[0] * (m+1) for _ in range(n+1)]
    for i in range(1, n+1):
        for j in range(1, m+1):
            if j >= w[i]:
                f[i][j] = max(f[i-1][j], f[i-1][j-w[i]] + v[i])
            else:
                f[i][j] = f[i-1][j]
    return f[n][m]
```

其中，n表示物品的个数，m表示背包的容量，w和v分别表示物品的重量和价值。



2、

01背包问题是一个经典的动态规划问题，可以通过以下步骤解决：

1. 定义状态：设dp[i][j]表示前i个物品放入容量为j的背包中所能获得的最大价值。

2. 确定状态转移方程：对于第i个物品，我们有两种选择：

   a. 不放入背包中，此时dp[i][j] = dp[i-1][j]

   b. 放入背包中，此时dp[i][j] = dp[i-1][j-w[i]] + v[i]，其中w[i]表示第i个物品的重量，v[i]表示第i个物品的价值。

   综上所述，状态转移方程为dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i])。

3. 初始化：当背包容量为0时，所能获得的最大价值为0，即dp[i][0] = 0。当没有物品可选时，所能获得的最大价值也为0，即dp[0][j] = 0。

4. 最终结果：最终结果为dp[n][W]，其中n为物品数量，W为背包容量。

使用这种方法，可以在时间复杂度为O(nW)的情况下求出最优解。

## 3、参考

https://zhuanlan.zhihu.com/p/545379010

https://blog.csdn.net/MSSPLANET/article/details/124854325

https://zhuanlan.zhihu.com/p/117476959